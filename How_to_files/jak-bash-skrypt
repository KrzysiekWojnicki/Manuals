ZNAKI SPECJALNE
-------------
* - dzika karta , dowolna długość dowolnego znaku
? - dzika karta , dowolny pojedyńczy zak
[] - powłoka generuje nazwy z podanych w nawiasach elementów , każdy nawias to jeden element
	> ls file[58a] [b39] 
	> file53
	# wszystkie dzikie karty można mieszać
	> ls file[!4]*
	> file1 file2 file3 fileabc
	# !4 to przywołanie numeryczne 
	# test[]
> test 10 -gt 20 ; echo $?
	# test sprawdzajacy czy 10 jest wieksze od 20 , zwraca 1 czyli true
> [ 10 -gt 20 ] && echo true || echo false
	# tak też można napisać , tym razem zwraca " true"
	# więcej testów jest na stronach podrecznika
	# [ -d foo ]  Does the directory foo exist ?
	# [-e bar ]  Does the file bar exist ?
	# ['/etc' = $PWD ]  Is the string /etc equal to the variable $PWD ?
	# [$1 != 'secret' ]  Is the first parameter different from secret ?
	# [55 -lt $bar ]  Is 55 less than the value of $bar ?
	# [$foo -ge 1000 ]  Is the value of $foo greater or equal to 1000 ?
	# ["abc" < $bar ]  Does abc sort before the value of $bar ?
	# [-f foo ]  Is foo a regular file ?
	# [-r bar ]  Is bar a readable file ?
	# [foo -nt bar ]  Is file foo newer than file bar ?
	# [-o nounset ]  Is the shell option nounset set ?

> source ./plik_wykonywalny
	#albo
> . ./plik_wykonywalny
	# tak można zmusić plik wykonywalny do rozruchu w tej samej powłoce
	# to się zowie sourcing

> bash -x plik_wykonywalny 
	# uruchamimy plik_wykonywalny w przez nas wybranej powłoce , tu BASH 
	# flaga -x to - pokaż jakie polecenia wykonujesz podczas uruchaminia

 #!/bin/bash -
	#or
 #!/bin/bash --
 	# ustrzegamy się skryptowania SETUID ,czyli ROOT SPOOFING -cokolwiek to jest
 
 count=42
 if [ $count -eq 42 ]
 then
 echo "42 is correct."
 elif [ $count -gt 42 ]
 then
 echo "Too much."
 else
 echo "Not enough."
 fi
 	# if elif then else 
 
 in 1 2 4
 do
 echo $i
 done
 	# for loop , można też napisać in {1..20} ,albo 'seq 1 20' "seq" to polecenie powłoki sequance , odlicza sekwencje
> for file in *.ksh ; do cp $file $file.backup ; done
	# pętle można też bezpośrednio urzyć w powłoce
	# polecenie file określa typ pliku
	# czyli każdy plik .ksh zostanie skopiowany pod nową zazwą *.backup

i=101;
while [ $i -ge 0 ] ;
do
echo Counting down, from 100 to 0, now at $i;
let i--;
done
	# while loop

let i=100;
until [ $i -le 0 ] ;
do
echo Counting down, from 100 to 1, now at $i;
let i--;
done
	# until loop

 #!/bin/bash
 echo The first argument is $1
 echo The second argument is $2
 echo The third argument is $3
echo \$ $$ PID of the script
echo \	# $	# count arguments
echo \? $? last return code
echo \* $* all the arguments
	# parametry skryptów , uruchamiając skrypt możemy podać 3 parametry
	# zostaną wyświetlone po koleji
	# zostanie wyświetlony PID skryptu
	# zostanie wyświetlony liczba podanych argumentów
	# zostanie wyświetlony return code
	# zostaną wyświetlone wszystkie podane argumety
	#
	# Więcej parametrów jest na stonach MAN , $O - to nazwa skryptu

The shift statement can parse all parameters one by one.
	# nie wiem jak to opisać bez długiego skryptu za przykład
	# najprośviej chodzi o to że 
	# while (( $	# ))
	# do
	# echo You gave me $1
	# shift
	# done
	# ----wyniki wyświetlą się jednen po drugim , każdy w nowej lini

#!/bin/bash
echo -n Enter a number:
read number
	# read to taki stdin<<

#!/bin/ksh
while getopts ":afz" option;
do
case $option in
a)
echo received -a
;;
f)
echo received -f
;;
z)
echo received -z
;;
*)
echo "invalid option -$OPTARG"
;;
esac
done
	# getops - umożliwia uźywania opcji przy uruchamianiu [liku_wykonywalnego
	# zmienna $OPTARG - to oczywiście opcja podana przez usera
;;
f)
echo received -f with $OPTARG
;;
	# taki zapis pozwala na nadanie opcji "f" argumentu

FUNKCJE
-------
generowanie losowych liczb
	r=$(( $RANDOM % 10 + 40 )); echo $r -generuje liczbe od 40 do 49
	r=$(( $RANDOM % 10 )); echo $r -generuje liczbe od 0 do 10
	grep -m1 -ao '[0-9]' /dev/urandom | sed s/0/10/ | head -n1
	shuf -i1-10 -n1 -tworzy losowe permutacje , -i to dolna górna liczba -n ilość wywołanych liczb

generowanie losowych stringów
	head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo ''
	</dev/urandom tr -dc 'A-Za-z0-9!"#$%&'\''()*+,-./:;<=>?@[\]^_`{|}~' | head -c 13  ; echo
		to ta sama komenda co powyżej ale więcej znaków jest wliczonych do puli , i ma pomieszaną kolejność
	openssl rand -hex 12
	openssl rand -base64 12   -inne sposoby na generowanie glosowych stringów
	date | md5sum   -najłatwiejszy do zapamiętania

GRUPOWANIE FUNKCJI
------------------
#!/bin/ksh

function pozdrowienia {
echo Witaj świecie!
echo i ty drogi $USER }

echo Przyzywamy naszą funkcje 
pozdrowienia
echo koniec
	
	W lini "pozdrowienia " wyświtla się dwie wcześniej zgrupowane linie

function plus {
let result="$1 + $2"
echo $1 + $2 = $result }

plus 3 10
plus 20 13
plus 20 22

	Funkcje też mogą przyjmować parametry
	Wynik to : 3 + 10 = 13

ZAGNIERZDŻANIE ZMIENNYCH
------------------------
> echo $(var1 = 5 ; echo $var1)
> 5
> echo $var1  
	# nie otrzymujemy nic
	# echo `var1=5;echo var1` orzymamy 5 . ` znak BACKTICK

WIELOKROTNE ZAGNIRZDŻANIE
A=shell
echo $C $B $A $(B=sub;echo $C $B $A ;echo $(C=sub; echo $C $B $A))
> shell subshell subsubshell


> (( 42 > 33 )) && echo true || echo false
true
	# The (( )) allows for evaluation of numerical expressions.
