SPIS TREŚCI:
	1.POLECENIA
	2.UPRAWNIENIA
	3.HISTORIA POWŁOKI
	4.ZNAKI SPECJALNE
	5.MANIPULACJA ŁAŃCUCHAMI I ROZSZERZANIE ZMIENNYCH
	6.ZAKRES ZNAKÓW
	7.STRUKTURA KATALOGÓW
	8.ZMIENNE SYSTEMOWE
	9.STRUMIENIE
	10.MYLĄCE PRZEKIEROWANIA
	11.WYRARZENIA REGULARNE
	12.BITY ODCZYTU
	13.ZARZĄDZANIE KONTAMI
	15.SKRÓTY
	16.SYSTEMD
	17.CRONTAB
	18.USŁUGI.SEVICES
----------------------

1.POLECENIA
--------
figlet - wieli baner z znaków ascii. NIE jest domyślnie zainstalowany
	figlet -f digital NAPIS -wyświetli baner zapis w formacie digital
	watch -n1 "date '+%D%n%T'|figlet -k"  -co sek. pokarze aktualny czas 
		w postaci baneru ze znaków ascii
dd - konwertuje i kopjuje pliki
	dd if=plik_wejściowy of=plik_wyjściowy conv=ucase  -zmieni małe na wielkie litery w nowym pliku
	???--- można konwertować pliki na wiele różnych sposobów , patrz MAN ---???
tput - inicjalizuj terminal lub pytaj bazę terminfo
	tput longname -pokarze pełną nazwe obecnego terminala
	tput -T konsole longname -pełna zawa konsole
	tput colors -liczba dostępnych kolorów
	tput cols -liczba kolumn na dostępnym ekranie (wierszy)
	tput lines -liczna lini (zanków w prawo)
	tpu cup 20 30 -przesunie kursor na ekranie 20 wierszy i 30 znaków
	tput setaf 3 ; echo napis będzie kolorowy  -self explanatory
infocmp - compare or print out terminfo descriptions
	infocmp konsole  -wyświeli liste możliwiści nazw terminala typu konsola
scrot - screenshot
dc - kalkulatror dowolnej precyzji (RPN -reverse polish notification). NIE jest zainstalowany
	dc 3 4 +p -dodawanie
watch - execute a program periodically, showing output fullscreen , domyślnie co 2 sek
	watch -n 0.5 free -m - pokarze status pamieci i update-jtuje go co 0.5 sekundy
	watch -d ls -l - pokazuje zmieniająca się zawartość katalogu
	watch -d 'ls -l | fgrep joe' - a teraz tylko te należące do usera joe
mesg - kotrola przesyłania informacji do twojego terminala
	bez parametrów wyświetla stan Y albo N
printf - formatuje i wypisuje dane
	printf "mój penis ma %d długości i jest %s " 20 olbrzymi
yes - domyślnie dodaje 'y' 
	yes | komenda - jeżeli komenda posiada zapytanie to odrazu odpowie yes
seq - sekfencja liczb
	seq 1 20 - odliczy od 1 do 20 , domyślnie zaczyna od 1 wiec można napisać tylko 20
	seq 3 9 - od 3 do 9
	seq 2 2 10 - policzy od 2 ,co 2 do 10
	seq -f "%02g/11/2018" 30 - policzy 30 dni październiak w podanym formacie
	seq -s , 10 - domyślnie zaczyna od newline ale można określić inny separator no; ','
	seq -w 100 - opcja wyświetli 001 002 003 itd.
	seq 10 -1 1 - odliczy od 10 do 1
expr - wykonuje obliczenia wyrażeń regularnych
	expr 2 + 4 -dodawani
	expr 10 % 3 -modulo
	expr 2 \* 7 - przy mnożeniu trzeba uciec aby bash nie zinterpretował * po swojemu
	expr length [sting] - poda długość stringa
	expr substr jakiśdługistring 6 5 - wytnie od 6 znaku 5 kolejnych ,otrzmamy 'długi'
	expt index cokolwiek k - poda liczbe (pozycje) w stringu którą zajmuje 'k'
talk - program do komuniksji między urzytkownikami w terminalu
write - szybki komunikator między urzytkownikamin na tej samej maszynie
	write [user] [tty] - syntax
source - is a builtin command of the Bash shell. It takes a file name, 
	and executes the commands in that file as if they had been typed on the command line.
export - wbudowane polecenie bash , eksportuje zmienne środowiskowe lokalne do globalnych
logname - pokazuje login name usera
uptime - pokazuje jak długo działa system od ostatniego boota
lpr - drukowanie off line ,wysyła plik do druku
lpq - program badający kolejkę buforowania druku
aspell - interactive spell checker
	-c -automatycznie spr.
	-l -pokaż błędy
dump - zapisuje całą partycje lub wybrane pliki na backup
	!!!--- UMOUNT-uj partycje przed ,aby uniknąć błędów ---!!!
restore - restore files or file systems from backups made with dump
slocate - NIEzainstolowany domyślnie - secure locate tz. że przeszuka pliki roota 
	ale nie wyświetli jego zawartości
	-u -tworzy index od root w dół
	-U -tworzy index od podręczego katalogu w dół
	-l 1|0 -on/off security
	-e katalog -exclude katalog z indexsu
	-d index.txt -zapisz do pliku index.txt
	-r regexp -szuka plików pasujących do regexp
accton / acctoff - wł/wył proces
dump-acct /var/account/pacct - drukuje plik acct 
dump-utmp /var/run/utmp - dtukuje plik utmp
last - (acct) pokazuje listing ostatnio logującuch userów
which - pokazuje ścieżke polecenia np; /usr/bin/which
sa - (acct) sumuryczne info o wcześniej wykonywanych poleceniach gdzie;
        	- 9.86re is a “real time” as per wall clock minutes
       		- 0.01cp is a sum of system/user time in cpu minutes
       		- 2466k is a cpu-time averaged core usage, i.e. 1k units
       		- sshd command name
	-c -najwyższy procen urzycia
	-m -numer procesu ,i numer minut CPU 
ac - ( polecenie usługi acct ) Wypisuje statystyki odnośnie  czasu  połączenia  użytkowników ,na podstawie pliku wtmp
	ac kw -dla użytkownika kw
	-d -info z kilku dni
	-p -dla każdego użytkownika , zamist sumy
lastcomm - (polecenie usługi acct) Print out information about previously executed commands.
	lastcomm kw -ostatni komendy usera kw
	lastcomm vim -ostatnie wywołanie vim
shuf - tworzy losowe permutacje
lsof - list open files , bez agrumentów pokarze wszystkie otwarte pliki w systemie
	lsof ścierzka/do/pliku --Which processes have this file open?
	lsof -p PID --Which files does process X have open?
	lsof -p `pgrep ABC` --albo tak
	Where is the binary for this process?
	lsof -p ABC | grep bin
	Which shared libraries is this program using? (manually upgrading software, i.e. openssl)
	lsof -p PID | grep .so
	Where is this thing logging to?
	lsof -p ABC | grep log
	Which processes still have this old library open?
	lsof grep libname.so
	Which files does user XYZ have open?
	lsof -u XYZ
	lsof -u XYZ -i # network only
	Which process is listening on Port X (or using Protocol Y)?
	lsof -i :80
	lsof -i tcp
readonly - wyświetli zmienne globalne tylko do odczytu tj.rzadna funkcja ich nie może nadpisać
	-f --funkcje readonly
logrotate - automaticlly purge messages
netstat -połączenia sieciowe
	-i -interfejsy sieciowe , bardzo ubogie info
		ale -ie -daje te same info co ifconfig
	-c -continuosly , co chwila wyświetla
		lepiej : watch -n 1 netstat -t -co sek. update netstat tcp
	-a -wszystkie połączenia
	-n -bez sprawdzania hostname
	-p -pokazuje PID i nazwe procesu , bardzo przydatne
		Niektóre procesy mają uprawnienia root i bez sudo nie podejrzymy PID
	-e -nazwa urzytkownika , -en -pokarze UID zamiast nazwy np; 1000 zamiast kw
	-n -adresy numeryczne
	-s -statystyki
	-r -kernel routing info . to samo co polecenie route
	-t -tcp
	-u -udp
	-g -all multicast network subscribet to this host
	-l -tylko porty które słuchają
	-tulpn
arp -a -Adderss Resolution Protocol , wyświelta sieci IPv4 z pamięci kernela ,
	flaga -a BDS style output format ,pokarze ipadres
	jeżeli w cache nie ma informacji o innych urządzeniach w sieci należy puścić pinga do
	szukanej maszyny , jeżeli odpowie info. o niej zostanie dodana do cache 
	-n -pokarze ip ,zamist hostname
	-a -inna forma danych :raspberrypi (172.16.15.254) at d4:ca:6d:0e:d6:19 [ether] on wlp2s0
	arp -d HWADDR -usunie z cache entry o podanym HW address
ssh -X ip_adres -połączenie z xserwerm na zdalnej maszynie , bez x tylko terminal
	ssh root@adres_ip -- łączymy się z kontem root na maszynie
	-p port -użyje wybranego portu , domyślnie 22
nice - nadaje pryjorytet procesowi . -20 najwyższy , 19 najniższy
	nice -10 cat > file --odpali z pry. 10
	nice --10 cat > file --odpali z pry.-10
renice - zmiejsza
	renice -n -19 -p PID --zmniejszy do 19 proces
nohup - to samo co & na końcu komendy , wrzuca w background
sar -u 1 3 -- sys.activity.reporting monitorowanie aktywności cpu , pamięci .Dmoyślnie może nie być zainstalowny
resize2fs /ścierzka_do_dysku -- zmiejsza file sys na wybranym dysku. Aby zmniejszyć logical.par. najpierw umontujemy dysk.
lvreduce - logical disk reduce
	lvreduce -L 3G /ścierzka_do_dysku --zmiejsza do 3 G
fsck - sprawdza system plików , tajk(tak jak) mkfs ma wiele modów do różny sf.
	!!!--- nie należy urzywać fsck na zamontowanym sf .
	wyjątk jeżeli w trybie pojedyńczego usera partycja podstawowa
	zostanie zamontowana w trybie tylko do odczytu ---!!!
	-p --automatycznie naprawia małe błędy , i tylko w poważnych wypadkach informuje
	-n --tylko sprawdzi , nie wprowadzi modyfikacji
	-b numer --można zastąpić uszkodzony superblok jedną z kopii utworzoną podczas tworzenia fs
mke2fs -n --wyświetli dla danego dev. liste bloków przechowujących kopie
e2fsck - sprawdza linuxksowy sys. plików ext..234 . Należy używać przy zmianie rozmiaru partycji
	-r --pamięć urzyta i wolna
	-fy /dev/cośtam --przepisuje dane z pliku dziebbika do bazy danych fs.
tmpfs - zmienne konfigurujące sposób montowania tmpfs w trakcie rozruchu,
	można przekształcić przestrzeń wymiany w coś w rodzaju tymczasowego dysku
ss - command use to dump socket statistics
	ss -t -a -To ss all TCP and UDP sockets on Linux
	ss -t -a -Z -Show all TCP sockets with process SELinux security contexts
vmstat - statystyki pamięci wirtualnej
	vmstat 2 6 - wywołuj co dwie sek , sześć razy
	- t --time format
vmstat - raport pamięci wirtualnej
tcpdump - sniffer do przechwytywania paczek otrzymanych albo wysyłanych przez sieć (TRZEBA ZAINSTALOWAĆ)
	tcpdump -i eth0 -łapie wszystko z wybranego interfejsu
	tcpdump -c 5 -i eth0 -złapie 5
	tcpdump -A -i eth0 -wyświetli w ASCII
	tcpdump -D -wyświetli dostępne interfejsy
	tcpdump -w 0001.pcap -i eth0 - zapis do pliku
	tcpdump -r 0001.pcap -odczyt
	tcpdump -i eth0 port 22 -łapie z portu
	tcpdump -i eth0 src 192.168.0.2 -łapie z źródła
	tcpdump -i eth0 dst 50.116.66.139 -łapie idące do celu
free - info o pamięci wykorzystanej w sys.
	-s N -pokazuje co N sekund
	-m mega bity
strace - śledź wywołania systemowe i sygnały
echo -e - uruchamia formatowanie tj; znaki \n \r itd . Uwaga muszą być w cudzysłowiu np; 'dupa\nupa\n'
	echo * - wyświetli liste plików w lini
lastb - to co wyżej ale dla root-a
du [plik] lub [katalog] - szacuje zużycie miejsca na dysku
	-S -dla katalogów z uwzględnieniem roz. podkatalo.
	- B mB - w mega bitach np.
	-h -human format
lsblk -wypisuje urządzenia blokowe
blkid - lista sys.plików z ich UUID (universally unique identifier)
	???---partycje FAT nie mają UUID ale można się do nich odwołać
	poprzez numer seryjny np;UUID="6528-6273" ---???
e2label - creating disc lables 
df - info o zużyciu przestrzeni dyskowej systemu pliku 
	-h human readable form
	-i -inode "węzły" An inode is a data structure that contains metadata about a file.
	???--- Everything about a file is in the inode, except two things : name them!
	The name of the file is in a directory, and the contents is somewhere on the disk. ---???
parted - pisać z sudo 
	-l listuje dyski i info o nich
fdisk - też z sudo
	-l jak wyżej
cat /proc/meminfo - info o pamięci sys.
cat /proc/partitions -  alternatywne sposoby podglądania utrządzeń
cat /proc/devices - wypisuje urządzenia blokow i znakowe , którym system przydzielił streowniki
cat /sys/block/sad/sad1/start -odczytuje liczbe która jest początkiem sektora
mount - wyświetli urządzenia dyskowe które już widoczne w systemie
	mount -t typ urządzenie punkt_montowania --montowanie
	np; mount -t ext4 /dev/sdf2 /mnt
	mount UUID=cośtam666 /mnt --montuje dev. o podanym uuid w /mnt
	-r --zamontuje sys.plików tylko do odczytu
	-o --umożliwia podanie długig opcji polecenia
		mount -t vfat /dev/hda1 /dos -o ro,conv=auto
		ro - to to samo co -r , conv=auto -nakazuje konwerowac znaki końca wiersza
		tu z formatu DOS na format właściwy dla danego systemu unix 
		exec , noexec - włącza i wyłącza możliwość uruchamiania progamu w danym sys.plików
		suid , nosuid - wł/wył możliwość korzystania przez progam z bitu setuid
		conv=text -wszystkie pliki będą traktowane jak tekstowe
		defaults - domyślne ustawienia (bity dostępu)
		noauto - pomija wpis w fstab
		user - umożliwia userom uruchomienie mount
	???---zazwyczasj typu nie trzba podawać ,jednak mkfs może mieć problem
	z rozpoznaniem różnych wariantów np FAT ---???
umount punkt_montowania --odmontowowuje , można też podać urządzenie
sync - synchronizuje zbuforowany zapis z trwałym nośnikiem
mkfs - tworzy wybrany system plików . patrz MAN ,lub /sbin/mkfs.*
ls -i -przegląda węzły inode
ls /dev/[s|x|v]d* - alternatywne sposoby podglądania utrządzeń
	-li -listuju węzły inode , pokarze numer węzła
ifconfig -a -wszystkie infomacje o urządzeniach sieciowych i ich stanie
	eth0 up -włącza , down -wyłącza wskazane urządzenie
	ifup , ifdown eth0 -tak też można wł/wył
ip address - info o sieci , tak jak ifconfig
lspci - listuje wszystkie podłączone urządzenia pci
nestst - z sudo , statystyki o połączeniach sieciowych
host - wyszukuje nazwy hostów , urzywając dns
	/etc/hosts - lista hostów , ona jest zawsze przeszykiwana pierwsza przed zapytaniem dns
	ale można zmienić to zachowanie edytując /etc/nsswitch.conf (name service switch)
	-p port -wybrany port tcp , domyślinie 43 (whatis service)
route - pokazuje / obsługuje tablicę trasowania protokołu IP
	route add -net 10.10.10.0/24 gw 192.168.0.1 - dodaje
	route del -net 10.10.10.0/24 gw 192.168.0.1 - delete
	route add default gw 192.168.0.1 - dodaje domyślny gateway
nslookup - odszukuje ipaddres hosta ,albo odwrotnie
traceroute - program służący do badania trasy pakietów w sieci IP. 
	traceroute ipaddress -albo- hostname - pokarze przez jakie routery leci paczka
	Pierwsza jest gateway naszej sieci potem ISP (Internet service provider)
	???--- domyślna paczka ma 40 bit ,jednak można to zmienić ---???
	???--- traceroute może iść inną trasą niż pobierane pliki albo email ---???
dig - lookup utilty ,zapytuje DNS o konkretne rekordy
	dig wp.pl - domyślnie wyświetli rekord A przechowujący IPaddress
	dig wp.pl mx - rekord mx (mail exchange record) , można też napisać dig -t mx -(type)
		NS - an authoritative name server
		CNAME - the canonical name for an alias 
	dig wp.pl any - wyświeli wszelkie rekordy
	dig wp.pl +short - sam address IP
		+noall +answer - polarze nam tylko sekcje answer
	dig @ns1.wp.pl. wp.pl - podejrzymy odpowiedź bezpośrednio od serwera nazw któy
		posiada odpowiedzialność za domene wp . Tego można znaleś pocją 'any'
	dig -f plik.txt - pobierze adresy z pliku np; wp.pl onet.pl
	.digrc - w kat. domowym możemy zrobić konfiguracje do dig-a
		po prostu piszemy np; +noall +answer  -i z takimi ust.domyślnie będzie dziłał
curl - narzędzie do transferu danych z i do serwera przy urzyciu różncy protokołów
	np; http, ftp i wiele innych . Różni się tym od wget że obsługuje wiele więcej protokołów 
	ma więcej metod autoryzacji
	???--- można potestować na https://jsonplaceholder.typicode.com ---???
	curl https://jsonplaceholder.typicode.com/users - pobierze informacje o userach ze strony
		-# -prosty progres bar
		-L -prekierowuje niedokładne adersy np; wp.pl na https://wp.pl
		-s -silet mode 
		-i - wyświetl też header
		-h - tylko header , -I -ten sam efekt
		-o plik.txt - zapisze wynik do pliku
		-O -zapisze nam wynik jako plik , w tym przypadku o nazwie 'users'
			można pobierać wiele: -O <URL> -O <URL> ..itd
		-O http://www.mysite.com/images/image[1-100].jpg -pobierz od 1 do 100nego obrazka
		-O http://www.{google,bing}.com - pobierze obie strony , google i blig
		-O --limit-rate 1000b - określimi limit przyłu danych na 1000bitów
		--data "title=Witaj&body=Witaj świecie" - zrobimy post do wybrnego targetu
			zawierający tytuł ,i body . -d -robi to samo
		-X put -d "title=dupa" - update-ujemy np;posts/1 nadając mu nowy tytuł
		-d name=john email=john@mail.com www.mysite.com/formpage.php -przekarzemy submit 
			data do formularza php . Gooole blokuje takie praktyki
			jest wicej opcji tego typu , -F koduje przesył np;obrazka
		-X delete - skasujemy
		curl -L wp.pl - przekieruje nas na prawidłowwy adres www.wp.pl
		curl -u kw:hasło - autoryzuje ,nazwa hosta i hasło
		curl -i kw@mój_ser:hasło -T plik.txt ftp://ftp.cośtam.com - uploudujemy plik 
			za pomocą protokołu ftp
			-O -zamiast T ściągamy plik 
host - wyszukuje nazwy hostów, używając serwerów domen
	host wp.pl - pokaże domyślnie dns record A
	host -t ns - pokaże domain name serwer
	host wp.pl ns1.wp.pl - pokaż konkretny name server
	host -a - wszystko , '-t any' -zadziła tak samo
	host 212.77.98.9 - pokaże nazwe dns
	host -v ..-pokaże w formacie TTL (jak polecenie dig)
hostname - nazwa komputera
	-i -ip addres
	-a -alias name
	-d -dns
	-F hostfile -ustawi hostname czytając z pliku hostfile
uname - info o maszynie
	-a -all
lscpu - info o architekturze procesora
nproc - liczba rdzeni procka
w - info o userach ,i tym co teraz robią
last - onfo o userach którzy się logowali ,i wylogowywali z systemu .
	urzywaj z tail i head bo plik jej balszoj
whoami - nazwa usera
who -r -sprawdza poziom uruchomienia systemu
	-H -w jednej lini
	-l -zdalnie zalogowani
id - info o user i jego grupie ,albo id root - info o root
	-G -pokazuje wszystkie grupy do których należy user
	-u -tylko user
	-g -tylko jego grupa
cp [co?] [gdzie?] - copy
cp -p - zachowuje arybuty domyślne takie jak właściciel i prawa dostępu
	-i -kopjuje hierarchie katalogów rekursywnie ,zachowuje pozwolenia i linki (-R -p -d)
	???--- Ciekawostka , jak plik można odczytać , to kopiując go bez opcji -p właścicielem staje się kopiujący ---???
scp - secure copy ,scp kopiuje pliki między komputerami w sieci. 
	Do transferu danych używa ssh(1) i wykorzystuje tę samą autoryzację 
	oraz daje takie samo bezpieczeństwo jak ssh(1).Scp pyta w razie potrzeby o hasła uwierzytelniające.
	scp plik.txt uesr@server_ip:ścierzka/docelowa -kopjuje plik.txt gdzieś tam
	-p -duplikuje atrybuty
	-r -rekursywnie katalogi i ich zawartość
	-v -rozległy output ,dobry do debugowania
ftp - file transfer protocol , server ftp 
	ftp adres_hosta -albo addressIP ,połączymy się z hostem
	ftp root@costm
		ftp> help -lista komend , ftp> ? -też help
		ftp> cdup -katalog wyżej
		ftp> get plik.txt  -pobiera plik
		ftp> mget *.txt  -pobiera wiel plików .txt
		ftp> put plik  -przesyła plik
		ftp> quit -wyjście
			-r -rekursywnie , katalogi z plikami
sftp - secure ,ale to nie ftp , to subsystem ssh , urzywa tego samego portu 22
	po prostu obsługuje się jak ftp
mail - prosty klien poczty
	mail root@abc.pl - wyśle rootowi ,zapyta o subjec , potem o body ,i o cc
	mail -włączy tryb wpisywania mail , i pojawi się prompt '&'
		? -wyświetli help
wget - pobiera strony www, pliki ,obrazy . Wget różni się tym od curl że pobiera rekuryswnie ,potrafi
	podążać za odnośnikami ,oraz jest nieinteraktywny czyli może działać w tle , przy zerwaniu 
	połączenia próbuje je zwnowić aż do skutku
	???--- libcurl -biblioteka z poleceniami curl dla jezyków programowania ---???
	wget -r www... -pobiera strone i inne 5 głębiej (domyślna głębokość)
		-r -l10 -głąbokość 10
		-r -l inf -nieskończoność , może też być 0
		???--- wget ma ponad 70 opcji ---???
mv [co?] [gdzie?] - move
rm - remove
	-rf rekursywnie force wsówa wszystko
rmdid - remove katalog
file [plik] - określa typ pliku
stat [plik] - statystyki pliku
	-f -jaki filesystem ,jaki rozmiar bloku i inne
	-l -podoąża za dowiązanimi
	-t -zwięzła forma , w jednej lini
wc - word count
nl - number line , numeruje wiersze w pliku
	-i 3 -wyświetli numerki co 3
less - podczas przeglądania pliku można:
	f -strona do przodu , lub ^V ,^F 
	b -trona do tyłu ,lub ^B
	? , / -wyszykaj do tyłu , przodu
		n , N - natępne , poprzednie
	v - edytuj w edytorze
	< , > - początek , koniec
	:n , :p - następny plik , poprzedni
alias e="echo" - tworzy alias dla echo
alias - pokazuje liste alisasów ; alisa l - pokarze alias do l
cal - pokazuje kalendarz ,ale tydzień zaczyna się od niedzieli
ncal - wertylakny ,normalnie od poniedziałku
reset - resertuje terminal
ps - wyświetla statut procesu
	-o pid,tname,time,cmd, - wyśietli podane kolumny
at - kolejkuje sprawdza lub usówa zadania do późniejszego wykonania
	at 9:30 PM Tue -albo- 22:30 10/21/2014 -albo- now + 30 minutes
	Bardzo elastycznie podchodzi do czasu , pozostaje tylko podać zadanie
	-m -wysyła maila z info o ukończeniu zadania
	-f -czyta polecenie z podanego pliku
	-l -alias dla atq
	-d -alias dla atrm
	atq - listuje zadania
	atrm - usówa zadanie
fg - for ground , przywraca na pierwszy plan zatrzymane polecenie
	fg % 2 - umieszcza prace o numerze 2 na forground
	fg % - wznowi ostatnią zatrzymaną prace
	% - to samo co wyżej
bg - background przesówa proces w tło
	opcje te same co przy fg
jobs - wyświetla zatrzymane procesy
	???---procesy są częścią działającego systemu , są znane tylko
	powłoką w których pracują ---???
disown %[number] - żaden terminal nie będzie właścicielem 
	praca będzie trwać nadal po jego zamknięciu
trap --wyświelti wszystkie trap-y ustawine aktualnie
	( trap słóży do chwytania sygnałów )
kill -Term -przerwanie procesu (SIGKILL ),domyślne ustawienie , to to samo co Ctrl+c 
	kill -l -lista sygnałów 
	-Cont -wznowienie zatrzymanego procesu ( patrz MAN 7 signal)
	-9 --sygnał kill , zabija proces i wyświetla killed
	kill -[signal] %[number] - Send the signal [signal] to job number [number]
locate - wyszukiwanie po indeksach, jak coś nie zostało zaindeksowane to nie znajdziemy
diff -q plik1 plki2 - porównuje pliki 
	q -informuje tylko że się różnią
	c1 -wypisze jedną linie oprócz zmienionych (domyślnie 3 ,samo c)
	y -side by side
cmp - porównuje pliki bit po bicie
sdiff - porównuje dwa pliki i tworzy trzeci plik zgodnie z instrukcjami
man -k -wyszukuje podręcznik po słowach kluczowych
info - coś jak man ale nie zawsze zawiera dokumentacje /usr/share/doc
whatis - wyszukuje w MAN , np whatis ls --> ls(1)
pv - (NIEMA TEGO DOMYŚLNIE , TRZEBA ZAINSTALOWAĆ) pasek postępu np; 
	pv duzy_plik | gzip > duzy_plik.gz - podczas pakowania mamy podgląd co się święci
stat jakiś_plki - pokazuje statystyki plilu , węzeł inode
touch -t - time stamp zmieniamy czas modyfikacji pliku rrrrmmddggmm
	-r - referens podajemy (plik1 plik2) - drugi plik zosatnie dotknięty pierwszym i oba będą miały taką samą date
	-a -zmini tylko czas wej.
	-m -tylko czas modyfikacji
	-d -timestamp "rr/mm/dd gg,mm" -ustawia date
	-c -jesli plik nie istnieje nie twórz go
batch - kolejkuje pliki , np; 
	echo gzip jakiś_plki | batch - wykona polecenie gdy obciążenie systemu spadnie ,domyslnie 1.5
	SPRAWDŹ MAN AT , BATCH 
tee - czyta ze standarowego wyjcia i zapisuje do pliku np;
	$ cat czytyaj.txt | tee temp.txt
	-a -append dopisuje zamiast natpisywać
whereis - lokalizuje pliki źródłowe i binarke progremu którego szukamy
type - typ pliku , czy jest wbudowny czy zainstalowany 
grep [co?] [gdzie?] - operator wyłuskiwania
	grep -n dupa plik.txt --pokarze na której lini w pliku jest dupa
	-c --count policzy ilość wystąpień 
grep -E 'ooo?' plik -szuka trzech liter "o" ale trzecia jest opcjonalna
grep [a]pache - grepuje pache z jednym znakiem (tutaj 'a' ,dowlony byłby '?') przed , czyli samo polecenie grep też na się nie wyświetli
grep [OPCJE] WZORZEC [PLIK...]
	-v odwrócenie wyszukania
	-i rozróżnienie wielkości liter
	-A1 również 1 lina po wyniku jest wyświetlana
	-B1 jedna przed wynikiem
	-C1 jedna po i przed 
grep a$ plik -gdzie ostatnia "a" w stringu
grep ^F plki - piewsza "F" w stringu
grep '\bdupa\b' plik - znacznik \b to spacja , czyli szuka słowa "dupa" w stringu
grep -w dupa plik - tak też szukamy słowa
	!!!!--- Wszystkie wyrarzenia umieszczamy w cytatach aby nie kolidowały ze spacjalnymi znakami powłoki
	jak np; $ ---!!!!
grep -E 'o{3}' plik -pokarze w pliku string gdzie są dokładnie 3 'o'
grep -E 'o{2,3}' plik -wybierze string gdzie 'o' występuje od 2 do 3 razy
cut - wycina kolumny z plików
	cut -d: -f1,3 /etc/passwd | tail -2
	otrzymamy	jan:510
			marian:511
	# innymi słowy wyłuska 1 i 3 pole które są rozdzielone znakiem ':'
		-d ogranicznik (delimiter)
		-f pola
	cut -d: -f1 /etc/passwd | column - wyświetli wszystkich lokalnych urzytkowników
	cut -c 12-16 -wpisze tylko znaki od 12 do 16 w każdym wierszu
ping -c 1 costam.ru | grep 'bytes from' | cut -d = -f 4 
	# jeden raz wywołujemy ping 
	# ze zwrotnej informacji wyłuskujemy linie zawierającą 'bytes from'
	# z wyłuskanej lini wybieramy 4 pole które jest oddzielone znakiem '='
column - bierze dane z wyjścia i wyświetla je w formie kolmn
let - ewaluacja zmiennch arytmetycznych np;
	let x="3 +4" - zmienna x równa się 7
	let x="0xFF' - zmienna x równa się 255
	let potrafi sobie przemienić system ósemkowy i szesnastkowy 
tr - translacja
	cat plik.txt | tr 'a' 'A' -zamieni a na A
	cat plik.txt | tr '\n' ' ' -zamieni zanak końca lini na spacje , tekst bedzie w jednej lini
	tr -s ' ' -zamieni wielokrotne spacja na pojedyńcze
	tr -d "\n" - skasuj wystąpienie nowej lini
sort - sortowanie alfabetyczne
	-n -sortowanie numeryczne 1,2,3 . a alfabet posortuje 1,100,2,20,..
	-r -revers sort
	--output='plik_wyjściowy' plik_wejściowy -zapisze wynik do wyjśiowego
uniq - unikaty , jak się powtarza to wyświetka raz
	 -c -wybiera i zlicza wystąpienia np; 1 jan , 1 marian , 3 dupa
	 --skip-char=1  -pominie pierwszy znak
comm - comparing streams (or files) , porównywarka
	comm file1 file2	| jan		 |
				|   	marian   |
				| dupa		 |
	domyślnie wyświetla 3 koluny 
	comm -13 - tylko 1 i 3 itd..
xxdiff - graficzny program do porównywania plików
paste -d ":" plik plik2 - skleja wiersze z dwuch plików 
	d -delimiter , bez nigo domyślnie jest \t (tabulacja)
join -join - łączy wiersze dwóch plików według wspólnych pól
	join -1 2 -2 3 t , plik plik2 -drugie pole w pliku1 bedzie wspólnym polem,
		trzecie z pliku2 też (jak sa identyczne np; nazwiska to sie połączą)
		t -delimiter , jak pola w wierszu sa rozdzielone np; "," to tak je join rozpozna
	-a 1 -zawartość pierwszego bedzie wyświetlona najpierw
fold - zawija tekst
	-w 16 -s  -zawiń teks po 15 znakach ,s -zapobiega rozdzielaniu słów w środku
fmt - prosty program formatujący tekst 
	bez parametrów wyświetla teks w jednej lini
	-w 20 -zawija tekst po 20 znakch
	-s -dzieli długie linie ,do długości , wszystkie kródsze zostaną pominięte
		czyli taka z 2 znakami taka zostanie
	-p '#' -nie pokarze lini zaczynających się znakiem '#'
	-u -unifikuje spacje
	-c indentation of 2 first line
	-g -width ,default 93%
od - pokazuje zawartość pliku w kodzie szesnastkowym 
	-b ósemkowym
	-c ASCII
xargs - wykonaj polecenie z arg. ze stdout
	echo {1..9} | xargs -n3  -wywoła 3 argumenty na raz , czyli 1,2,3 ,i 4,5,6 w nowej lini itd.
find / -name *.txt | xargs grep -i dupa --odszuka w całyej gałęzi nazwy *.txt i 
	wybierze tylko te z stringiem dupa
	-maxdepth -1  -przeszuka tylko bierzący katalog ,określamy głębokość szukania
	-delete  -find domyśli robi print ale możemy skasować wyniki
find . -printf "%M\t%u\t%p\t%g\n" - wyświetli coś jak ls -l , trzeba tylko konkretny katalog wybrać bo wyrzyga wszystko
find - szuka
	find . -name "*.conf" - szuka w aktualnym folderze po nazwie
		-type -d -szuka katalogów
		-newer file42 -nowszych niż plik file42
	find /data - name "*.odf" -exec cp {} /backup/\; kopiujewybrane pliki do backup
		polecenie {} -pyta o zgode ok?
	find -inum 817270 2> /dev/null -szuka węzła inode o podanym numerze (ratycje mają swoje osobne kolekcje węzłów)
			-samefile nazwa -Plik odnosi się do tego samego i-węzła co nazwa. Gdy działa opcja -L, obejmuje to dowiązania symboliczne.
locate - raczej nie istnieje domyślnie w systemie. Wyszukuje po indeksach, jeżeli są niaktulane trzeba zrobić UPDATEDB
date +%s - czas UNIX-owy w sekundach
bzip2 - kompresja w bzip
gzip - kompresja w gzip
gunzip - dekompresuje gzip
zcat 
zmore - oba to podgląd skompresowanych gzip
bunzip - dekompresja bzip
bzcat
bzmore - podgląd gzip
ln - tworzy hard link (ma taki sam inode , musi być na tym samym dysku)
	-s --tworzy link symboliczny ,inny inode , dowolne miejsce nawet inna sieć
tar cvf archiwum.tar plik1 plik2 ... - tworzy archiwóm z podanych elemetów
	-c tworzenie archiwum
	-v tryb wypisywania danych diagnostycznych (podgląd)
	-vv drugie v to szczegułowe info (rozmir..)
	-f nazwa pliku (trzeba po tym argumencie podać nazwe , ale jest wyjątek przy sdtout ,istdin wtedy można napisać -f - myśnik)
tar xvf plik.tar [nazwa pliku składowego]-opcjonalnie 
	-x tryb rozpakowywania
	-t tryb wyświetlania zawartości pliku tar
	-p zachowanie uprawnień plików z archiwum
zcat plik.tar.gz | tar xvf - (rozpakowywanie ,i rozariwizowanie w potoku)
	zcat <---> gunzip -dc (to to samo)
	-d dekompresja
	-c wysyłanie wyniku na stdout
tar ztvf plik.tar.gz - spradza zawartość archiwum
	-z automatyczne uruchaminie gzip
	-j automatyczne uruchaminie bzip2
	.tgz <---> .tar.gz
set -x [plik] - ustawia wykonywanie dla pliku dla usera,grupy,innych
set +u - domyślnie jeśli zmienna nie istniej to nie pojawi się nic , opcja set +u wyświetli nam wiadomość że zmienna jest unabled . 
set -u - wraca do stanu domyślnego
	set +u <--> set +o nounset
	set -u <--> set -o nounset
printenv - wyświetla zmienne środowiskowe
env - wyświetla exportowane zmienne
	-i - czyści środowisko dla zmiennych dla danego skryptu
	-u ZMIENNA -unset pomija zmienna w skrypcie
rename 's/string/inny_string/'* - szuka wzorca i podmienia nazwe
rename 's/text/txt/' *.text - zamiana rozszerzenia na txt
rename -n 's/TXT/txt/g' aTXT.TXT 
	-n - pokarz pliki które pomienisz
	/g -global
rename 's/.txt/.txt/i' * -podmieni wszystkie rozszrzenia , ale tylko małe litery
	/i -case sensitive
rename 's/.txt$/.TXT/' *.txt - znak '$' znaczy at the end (na końcu) 
	czyli jakmamy plik.txt.txt to zamieni na plik.txt.TXT 
awk - czyli qawk język wyszukiwania i przetwarzania wzorców.
	awk '{ print $3 }' filename - wyświetli string z pliku w trzeciej kolumnie
	awk '{ print }' filename - wyświetli zawartość pliku , jak cat
	awk '/b/ { print $2 }' filename - wyświetli wsłystkie zaczynające sie na małe b ,w 2 kolumnie
	awk '/^[0-9]/ { print }' filename - wyświetli każdą linie zaczynająca się od dowolnego znaku
	awk '/[a-z]$/ { print }' filename - wyświetli każdą linie kończącą się na dowolnej małej literze
	awk '{ if($2 ~ /dupa/) print }' filename - jeśli w 2 kolumnie jest dupa ,to wyświetl
	awk -F: '{ print $1 }' - zastąpi nam delimiter w postaci : na spacje(domyślny delimiter awk)
sed -edytor strumieniowy do filtrowania i przekształcania tekstu
	sed 's/t/ooo/' - zamieni pierwsze wystąpienie 't' w każdym wierszu na 'ooo'
		"s"to substitute ,zastępowanie
		-i -interactiv mode , dokonuje permanentnych zmian w pliku
	sed -f skrypt_sed text -zmodyfikuje plik text skryptem sed
		skrypt piszemy poprostu podając polecenia
			s/t/T/g
			s/\w*.//g
	sed 's/\bkot\b/pies/g' - zamieni kot na pies 
		\b -bounds ,granice ,czyli nie uwzględni kotwatość , a jedynie stricte kot
	sed -n 's/słowo/&/gp' - wyświetki tylko linie gdzie wystąpiło 'słowo' coś jak grep
		-n -silen mode , nic nie wyświetla
		/p -tylko przypadki
		/I -wielka litera I na końcu to case sensitiv 
	sed '/bzdury/dg' - d usunie bzdury globalnie , niema znaczenia wileki czy małer d
	sed '4 q' - wyświetl 4 linie i quit
	sed '5,& d' - wyświetl 5 zakończeń lini i usuń (piątą i reszte) sposób wyżej lepszy
	sed '1!{/^#/d;}' -skasuje wszyskie linie zaczynające się od znaku "#" z wyjątkiem pierwszej
	sed -n '$=' -nie wyświetlaj nic ,ale podja numer wierszy , i tylko ostatni
		= -podaje numer lini
	sed '=' text | sed 'N; s/\n/---/' -ponumeruje linie , doda nową linie ,a w jej miejscu wstawi "---"
		N -append ,doda do ciągu 
		\n -new line
	sed 's/./&\n/g' - weź każdy znak "kropka" i wyświetl w nowej lini
	sed 'n,d' - kasuj nową linie , czyli 1 wyświetli ,2 nie bo nowa linia , potem wyświetli 3 itd.
	sed -n 'p,d' - wynik jak wyżej ale inaczej bo wyświetlamy tylko wybrane linie
	sed '1!n,d' - to co wyżej ale pomiń pierwszą , czyli 2,4,6 itd.
	sed -n 'p,n,n,n' - wyświetli co 3 linie ,itd
	sed 's/[0-9]/ooo/g' - zamieni wszystkie liczby na 'ooo'
	sed 's/[a-zA-Z]/ooo/g' - zamieni wielkie oraz małe litery
	sed 's/[A-z]/ooo/g' - to co wyżej . 'A' musi być najpierw bo w tablicy ASCII wielkie występują 
		wcześniej ,i  idwrotna kombinacja nie zadziała
		Skrót dziła na tej zasadzie że oznaczmy na tablicy ASCII dwa punkty
		a wszystko i wszystko między nimi jest wliczone w nasze zainteresowanie
		ale uwaga bo między 0-z są też inne znaki takie jak np '.' '?' itp.
	sed 's/[0-Z]/ooo/g' - jeszcze jeden skrót , wszystkie liczby i wielkie litery 
		[0-z] - zastąpi wszystkie numery i liczby
	sed 's/[0-9]i/ooo/g' - zastąpi każde wystąpienie liczby po której występuje litera 'i'
	sed 's/[0-9]//g' - usunie liczby
	sed 's/t/ooo/g' - xrobi to samo tylko globalnie w człym tekście
	sed 's/^t/ooo/g' - zamieni tylko te 't' które znajdują się na początku lini
	sed 's/t$/ooo/g' - zamieni tylko te 't' które są na końcu lini
	sed 's/[0-9]/(&)/g' - zamieni każdą cyfre na tą cyfre ale w nawiasach
		"$" to wynik wyszukania
		To zapytanie rozdzieli dziesiętne i większe liczby na pojedyńcze
		[0-9][0-9]* -doraźnie pomoże , "*"oznacza pierwsze lub pierwsze i drugie
	???--- W sed znak '/' można zastąpiś : _ |    ----????
	sed 's_/usr/share/local_ooo_g' - inny delimiter dla czytelności tekstu
		delimiterem może być cokolwiek
	sed 's/[^0-9]/ooo/g' - zastąpi wszystko ,nawe spacje, poza liczbami
	sed 's/a/1/g;s/b/2/g' - dwa zadania dla sed rozdzielone ';' jak w skryptach bash
	sed 's/\w*//g' - symbol \w* oznacza pierwsze słowo a-z 
		dodatkowo \w*. -spacja po słowie też zostanie usunieta
		\w*$ -ostatnie słowo
	$ echo Sunday | sed 's_\(Sun\)_\1ny\1_' -otrzymamy Sunny Sunday
	$ echo 2014-04-01 | sed 's/....-..-../yyyy-mm-dd/' -otrzymamy yyyy-mm-dd .Kropka zastępuje dowolny znak
	$ echo -e 'today\tis\twarm' | sed 's_\s__g' -otrzymamy todayiswarm , nie wiem czy taki miał być wynik \s -to white spaces
	'x/d' -karzda linia zawierająca x zostanie przesiana
	$ cat plik | sed 's/o\{3\}/A/' -zastąpi 3 'o' na A
udevadm info --query=all --name=/dev/sda -wyświetli ścieżkę i inne atrybuty użądzenia	
	P: ścieżka urządzenia w systemie sysfs
	S: dowiązanie symboliczn do urządzenia utworzonego prza proces udev w /dev
	N: węzeł urządzenia , czyli nadaną nazwe plików w /dev
	E: dodatkowe info o urządzeniu pobrane z reguł procesu udev
udevadm monitor - monitorowanie 
dmesg - wypisuje ostatnie komunikaty jądra
	dmesg | grep "irq 1[45]" - wyszukuje IRQ (interrupt request) onumerz 14 i 15 podczas bootowania
	IRQ to sygnał urządzenia do CPU ,bo na przykład ma dane gotowe do urzycia
pwgen - generuje randomowe hasło . Nie jest domyślnie zainstalowany do dystrybucji
	pwgen -s 12 3 -stworzy 3 hasła o 12 znakch , -s to more secure (hasła mają wyszą entropie)
gpw - generuje losowe ciągi liter dla np, nazw userów
	gpw 3 13 - trzy hasła o 13 literach
block --rereadpt /dev/sda -polecenie wymusza na jądrze systemu ponowne załadowanie tablicy partycji urządzenia sda


2.UPRAWNIENIA
-----------

1	nywanie	--x
2	Zapis	-w-
3	Zapis i wykonanie	-wx
4	Odczyt	r--
5	Odczyt i wykonanie	r-x
6	Odczyt i zapis	rw-
7	Odczyt, zapis i wykonanie	rwx

3.HISTORIA POWŁOKI
----------------
! +znak - rzywrac komende która zaczyna się od znaku
! +numer - komenda o numerze
$HISTFILESIZE- zmienna pokazująca akualny rozmiar biblioteki
$HISTFILE - pokazuje gdzie znajduje się plik z historią bash
histsize = 100 - ustawi nam rozmiar histori na 100



4.ZNAKI SPECJALNE
---------------
* - dzika karta , dowolna długość dowolnego znaku
? - dzika karta , dowolny pojedyńczy zak
[] - powłoka generuje nazwy z podanych w nawiasach elementów , każdy nawias to jeden element
	> ls file[58a] [b39] 
	> file53
	# wszystkie dzikie karty można mieszać
	> ls file[!4]*
	> file1 file2 file3 fileabc

; - rozdziela polecenia w tej samej linie
& - postawiony na końcu polecenia wrzuca je w bacgroun , można pojerzeć - jobs
$ - zmiena środowiskowa np; $user $uid
$? - parametr powłoki w którym przechowywany jest code wyjścia poprzedniej powłoki np; echo $? - jak zwraca 0 to nie ma error
$#    Stores the number of command-line arguments that 
      were passed to the shell program.
      $?    Stores the exit value of the last command that was 
            executed.
	    $0    Stores the first word of the entered command (the 
	          name of the shell program).
		  $*    Stores all the arguments that were entered on the
		        command line ($1 $2 ...).
			"$@"  Stores all the arguments that were entered
			      on the command line, individually quoted ("$1" "$2" ...).
			      /command -yes -no /home/username
			      $# = 3
			      $* = -yes -no /home/username
			      $@ = array: {"-yes", "-no", "/home/username"}
			      $0 = ./command, $1 = -yes etc.
			      $$ = PID procesu
&& - logiczne AND czyli I
|| - logiczne or
\ - znak ucieczki
# - znak komentarza w skryptach sh.
	Other # uses in Bash
	The # is often used in bash to count the number of occurrences or the length of a variable.
	
	To find the length of a string:
	
		myvar="some string"; echo ${#myvar}
		returns: 11
	
	To find the number of array elements:
	
		myArr=(A B C); echo ${#myArr[@]}
		returns: 3
	
	To find the length of the first array element:
	
		myArr=(A B C); echo ${#myArr[0]}
		returns: 1 (The length of A, 0 is first element as arrays use zero-based indices/subscripts).


5.MANIPULACJA ŁAŃCUCHAMI I ROZSZERZANIE ZMIENNYCH
----------------------------------------------
${parameter:-defaultValue}	Get default shell variables value
${parameter:=defaultValue}	Set default shell variables value
${parameter:?"Error Message"}	Display an error message if parameter is not set
${#var}	Find the length of the string
${var%pattern}	Remove from shortest rear (end) pattern
${var%%pattern}	Remove from longest rear (end) pattern
${var:num1:num2}	Substring
${var#pattern}	Remove from shortest front pattern
${var##pattern}	Remove from longest front pattern
${var/pattern/string}	Find and replace (only replace first occurrence)
${var//pattern/string}	Find and replace all occurrences

6.ZAKRES ZNAKÓW
-------------
ls file[0-9] - plik z dowolną liczbą od 0 do 9 na końcu
ls file[a-z] - to samo dla a-z
$LANG - w zależności od ustawienia tej zmiennej wyniki wyszukiewania a-z lub A-Z mogą być inne gdyż niektóre języki nie rozróżniają wielkości liter


7.STRUKTURA KATALOGÓW
------------------
/bin - pliki binarne dla wszystich urzytkowników
/home/marian/bim - pliki binarne mariana w jego katalogu domowym
/sbin - pliki binarne do kofiguracji systemu , dostęp tylko dla ruta lub sudoera
/usr - Drugorzędowa hierarchia dla danych (ang. Unix system resources), dane tylko do odczytu.
/usr/info -dokumetacja GNU , nie wszysto tu jest ale można szkać ,wpisujesz $ info temat
/usr/lib - pliki wspólne ,stateczne , i pomocnicze
/usr/lib/system/system - konfiguracja globalna , lepiej tego nie ruszć , w zamian /etc/systemd/system
/usr/local - Trzeciorzędowa hierarchia danych lokalnych (ang. local data), specyficzna dla tego hosta. Tu admin może lokalnie instalowć software
/usr/share - Dane niezależne od architektury, a więc między nimi współdzielone (ang. shared).
/usr/shared/games - statyczne pliki gier np; play log , high score
/usr/src/ - Kod źródłowy (ang. source code; np. źródła kernela z jego nagłówkami)
trap --wyświelti wszystkie trap-y ustawine aktualnie
	( trap słóży do chwytania sygnałów )
/usr/include/ - standardowe pliki nagłówkowe (do kompilatora c)
/lib - biblioteki dla plików binarnych /bin i /sbin , zawiera pliki wspólne
/lib/modules -moduły jądra
/opt - opcjonalny software irm trzecich 
/boot - pliki potrzebne do rozruchu systemu , są tu grub.cfg , grub.conf , kernel
/etc - pliki konfiguracyjne systemu , urządzeń , sieci , i hasła
/etc/ssh/sshd_config - plik z ustawieniami ssh
	zawiera info o domyślnym porcie 22
	oraz Authentication , gdzie w polu PermitRootLogin możwmy ustawić wartiść NO
	aby uniemożliwić logowanie się przez ssh za pomocą hasła , a jedynie klucza ssh
/etc/fstab - plik ze statycznymi informacjami systemu plików
/etc/network/interfaces - opisuje dostępne na systemie
/etc/init.d - pliki stop-start demon czyli usługi , albo unity w systemd
/etc/skel - "szkielet" który jest kopiowany do nowego pliku home urządzeń ,zazwyczaj zawiera .bashrc
/etc/X11 - pliki konfiguracyjne grafiki
/etc/opt - pliki konfiguracyjne dla katalogu opt
/etc/xml - pliki konfiguracyjne dla xml
/etc/shadw - zahaszowane hasła , można sobie skopiować i na swoje się wkleić
/etc/profile - ustawienia profilowe dla powłoki bourne-a
/etc/systemd/ststem - definicje lokalne , tu można bezpiecznie umieszczać własne zmiany
/media - Punkty montowań dla nośników wymienialnych (ang. media; np. CD-ROMów) (pojawiło się w FHS-2.3).
/srv - 	Dane specyficzne dla miejsca (site-specific), które są udostępniane (ang. served) przez system.
/mnt - Punkt montowania (ang. mount point) innych niż natywny systemów plików.
/dev - device; np. /dev/null 
/dev/tty1 -pirwsza konsola wirtualna
/dev/ttyUSB0 -port usb
/dev/zero - niprzerwany ciąg plików , jest źródłem danych
	dd if=/dev/zero of=przyklad bs=1k count=100 - za pomocą dd można zapchć dysk danymi z /dev/zero
/dev/random - generator liczb losowych w postaci losowych bajtów
/dev/urandom - inny generator losowych rzeczy
/dev/full - zwraca: No space left on device (symbol ENOSPC) przy próbie zapisu do niego. Jest używany do testowania zachowania programów przy braku miejsca na dysku 
	$ echo Hello world > /dev/full
	bash: echo: write error: No space left on device
/dev/pts i /dev/tty - terminale
/var - 	Pliki często ulegające zmianom (ang. variable files), takie jak: logi, bazy danych, tymczasowe pliki e-mail.
/var/tmp - podobne do /tmp ale pliki są zachowywane po zamknięciu sytemu
/var/log - logi
/var/log/syslog - info o tym co się stalo w systemie
/var/lib - info o stanie aplikacji
/proc - Wirtualny system plików proc informujący o stanie systemu i poszczególnych procesów, w większości pliki tekstowe (np. uptime, network).
/proc/partitions - info o partycjach
/proc/cmdline - parametry jądra użyte przy uruchamianiu jądra
/sys - informacje kernela o hardware

8.ZMIENNE SYSTEMOWE
-----------------
$HOME - katalog domowy usera 
$LANG - zmienn przchowyjąca kodowanie znaków np; utf-8
$DISPLAY - nazwa x którego urzywasz
$OLDPWD - poprzedni katalog
$TERM - terminal
$LOGNAME - login name
$EDITOR	- domyślny edytor tekstu
$VISUAL - też domyśly edytor 
	różne programy wybieraj inna zmienną ,dobrze mieć obie zmienione
	export EDITOR VISUAL - ustawia obie


9.STRUMIENIE
-----------
polecenie >| plik - wymusza nadpisanie jeśli przy > jest odmowa
polecenie > plik -zapisujie lub nadpisuje stdout
polecenie >> plik -dopisuje na końcu pliku
polecenie > plik 2>&1 -zapis do pliku stdout i stderr
head < /proc/cpuinfo
head /proc/cpuinfo -oba to to samo
2> - przekierowuje stderr
1> - przekierowuje stdout , to samo co >
&> - łączy stdout i stderr w jeden strumień
0< - to samo co < ,czyli stdin
<<< - przekazuje ppolecenie bezpośrednio
	base64 <<< dupa 	wynik to b38yf239
	base64 <<< b38yf23	wynik to dupa
> plik - najszybsza matoda na wyczyszczenie pliku
>| plik - a tak gdy jest włączony nocluber czyli set -u

10.MYLĄCE PRZEKIEROWANIA
--------------------
powłoka skanuje całą linie zanim dokona przekierowania
cat w.txt > s.txt 2>e.txt
2> e.txt cat w.txt > s.txt
< w.txt > s.txt 2> e.txt
wszystkie komendy zrobą takie samo zadanie

11.WYRARZENIA REGULARNE
--------------------
BRE - basic regex
ERE - extsnded regex
PRCE - perl regex
	grep -E   zmusza czytanie stringa jako ERE
	     -G jako BRE
	     -P PRCE
	     -F dosłownie
PRCE i ERC używają | jako logicznego OR 
	grep -E 'i|a' plik	tania laura -jest "i" i "a"
		'*' 	oznacza zero , jeden ,lub wiele wystąpień w poprzedającym
		'+'	oznacza jeden lub więcej wystąpień
rename (to PRCE swoją drogą)
ala{ma,dypa,y,x}kota - dopasuje wszystkie wyniki z uwzglendnieniem opcji z nawiasów
^V - ucieczka znaków kontrolnych
	echo "tu jest^V^Itabulacja" -otrzymamy- tu jest		tabulacja

	

12.BITY ODCZYTU
------------
-r--r--r-- -typ (d,s,l) użytkownik grupa inni_użytkownicy
	s - to stemp etuid czyli identyfikator użytkownika (passwd tak ma aby root mógł zmienić hasło)
chmod go+r plik - dodajemy grupie i innym(others) prawa do read ( a u to user:)
chmod u=rwx,ug+rw,o=r permissions.txt - kombinacja pozwoleń dla usera ,grupy ,i reszty
chmod 644 plik - TRYB BEZWZGLĘDNY wszystkie bity są zmienione
	1--x 2-w- 3-wx 4r-- 5r-x 6rw- 7rwx 0---   SYSTEM ósemkowy
umask - pokaże domyślne ustawienia dla nowych plików , np;0022 
	-S pokazuje w formacie u=rwx,g=rx,o=rx

--"sticky bit""setgid""setuid"---
chmod +t -dodaje "lepki bit" ,dodanie go do katalogu zapobiega usówaniu plików urzytkownikom którzy nie są ich właścicielami . 
	Bit symbolizuje litera 't' jeśli x jest ustawiony , i 'T' jeśli nie np; drwxr-xr-t
	chmod 1775 -jedynka symblizuje lepki bit
Aby ustawić bit grupy "setgid" można urzyć dwójki np; 
	chmod 2775 lub 3 ustawi nam "setuid"
	chmod 4775 ustawi "setuid"
	innym sposobem jest dopisanie u+s , g+s , o+t
	Bit grupy "setgid" na katalogu powoduje że wszystkie pliki w nim są własnością grupy rodzica czyli katalogu a nie grupy tego kto je tam stworzył
	Bit grupy na pliku powoduje że plik uruchamia się z przywilejami grupy właściciela pliku ,a nie tego kto go uruchamia
	bit "setgid" i "setuid" jest symbolizowany prza 's' i 'S' dla braku x
	bit "setuid" ustawiony na pliku powoduje że plik jest uruchamiany z przywilejami właściciela pliku ,a nie tego kto go uruchamia
find / -type d -perm -2000 2> /dev/null -odnajdzie nam wszystkie katalogi z ustawionym setgid
find /usr/bin -type f -perm -04000 -odnajdzie wszystkie pliki z ustawionym steuid
getfacl plik - pokarze acls (access control lists) danego pliku
setfacl - pozwal ustawić acls pliku np;
	setfacl -m u:sandra:7 file33 -ustawi dla urzytkownika sandra rwx
	setfacl -m g:tennis:6 file33 -ustawi dla grupy tenis rw-
	setfacl -x sandra file33 -usunie wszystkie przywileje sandry
	setfacl -b file33 -usunie wszystkie ustawienia acls z wybranego pliku
	setfacl --no-mask -m u:sandra:7 file33 -opcja no-mask doda #effective:rw- czyli ustawienie maski acls bedzie zignorowane , a efektywne będzie ustawione na połączenie wszystkich grup będącej właścicielem i wszystkich nazwanych wpisów użytkowników i grup.
	
13.ZARZĄDZANIE KONTAMI
-------------------
	/etc/passwd -- kowalski:x:3676:1000:Jan Kowalski:/bin/bash
	nazwausera:hasło(x oznacza że hasło jest w etc/shadow):id:grup_id:nazwa_rzeczywist:powłoka
	???--- można stworzyć pseudo usera bez praw zapisu ani logowania ,jednak
	system może uruchamiać procesy z jego identyfikatora ---???
users - wszyscy aktualnie zalogowni
useradd - dodawanie usera
	useradd -m -d /home/yanina -c "yanina wickmayer" yanina
	-m -tworzy katalog domowy 
	-d - nazwa tego katalogu
	-c -opis konta
	-D -opis twojego stanu konta
userdel -r - kasuje rekursywnie z katalogiem domowym
usermod - zmienia informacje konta
	-s - zmienia powłkę urzytkownika
	-L -zawiesza hasło . W pliku /etc/shadow dodaje na początku hasła '!' co powoduje niemożność zalogowania
	-a -G -dodaje grupe do usera , -a append -dopisuje , bez tego nadpisze
	!!!--- Natomiast nadal urztkownik może się zalogować przez SSH ---!!!!
	-U -odwiesza wcześniej zawieszone hasło
vipw - bezpieczny sposób na edycje /etc/passwd i /etc/shadow
vigr - bezpieczna edycja /etc/group -pliku mówiącego kto do jakich grup należy
	/etc/group - nazwa/hasło/GID/kto_należy
chsh - zmienia powłokę na inna wybną znajdującą się w /etc/shells
	-l -listuje wszystkie powłoki
	-s /etc/ksh - zmienia na krona
chfn - change full name - zmienia dane usera , imie,naz,tel,itp
	-f name ,-h phone , -o office
grep ^PASS /etc/login.defs - tutaj są domyślne ustawienia dla haseł urzytkowników jak minimalna długość 
	grep słowo plik.txt -przeszuka plik wyłuskując linie zawierające słowo
	grep color=auto słowo plik.txt - tak jak wyżej ale podkoloruje mu wynik
		$ export GREP_OPTIONS='color=auto' -ustawienie konfiguracyjne na auto color dla grep
	grep -i -case sensitiv
chage - edycja ustawień haseł , passwd też ma takie możliwości
chage -l kw -informacje o ustawieniach hasła dla urztkownia kw
passwd - ustawia hasło np; passwd kw
	-d -szybkie usuwanie hasła
	-l -lock , to samo co usermod -L , czyli '!' na początku hasła /etc/shadow
	-S -info , jak na początku jest L -zanczy locked
	-f -rzeczywista nazwa usera
	-s -powłoka
vipw - bezpieczny sposób na edycje /etc/passwd i /etc/shadow
openssl - szyfrowanie
	openssl aes-256-cbc -a -salt in plik_do_szyfrowania -out plik_zaszyfrowany
	-a - ASCII , zaszyfrowaną wiadomość będzie można wyświetlić w formie ASCII
	aes-256-cbc - rodzaj szyfrowania
	openssl aes-256-cbc -d -a in plik_zaszyfrowany -out plik_odszyfrowany
	-d - odszyfruj
openssl passwd hasło - szyfrowanie hasła hasła
openssl passwd -salt 666 hasło - dodana sól będzie pierwszymi znakami tj; 666jbnshjvbjvb
useradd -m -p $(openssl passwd hunter2) mohamed - a tak stworzyć zaszyfrowane hasło mochamedowi !!!--tak stworzone hasło będzie widoczne w historii ---!!!
????---> można napisać program w C używający funkcji do szyfrowania <---????
groupadd - dodaje grupe
	nazwa_grupy:hasło(jak x to shadow):id:członkowie,wielu.wielu
	-f -nie pozwala aby nazwa się powtarzała
	-g GID -sami wybieramy GID
groups - polecenie pokazujące grupy do których należy user
groupmod - modyfikuje nazwe,id,passwd
	usermod -a -G tennis,sports kw - dodaje urzytkownika kw do grup . -G -grupy ,-a append
groupdel - wiadomo . Dobrze jest przed skasowaniem spr. które pliki mają ID tej grupy
	find / -group nazwa_grupy -print
gpasswd - edycja /etc/group o /etc/gshadow - pliku z danymi kto jest adminem
	- A -minowuje admina , admin może się wypisać z grupy
	-a -dodaje do grupy ,-d -usówa
	gpasswd -A serena sports - serena jest teraz adminem grupy sports
chgrp - zmień grupe , np; chgrp grupa2 plik - plik teraz jest własnością grupy 2
chown - właściciel pliku/katalogu np; chown kw plik
	chown kw:grupa2 plik - zmienia właściciela i grupe
chattr - zmienia atrybuty plików	
	u -niekasowalność , zobacz też inne [aAcCdDeijsStTu]
	a -append only
	A -access not timestamp , nie zmieni timestamp
	c -skompresowane w zapisie , rozkompresowane w odczycie
	d -don't dump , pominie przy robieniu kopii
	i -immutable , niezmienialny , niskasowywalny
	s -secure deletion ,przy kasowaniu plik jest zapisywany zerami
	S -synchronous update ,informacje są odrazu synchronizowane przy zapisie

lsattr - wyświetla atrybuty pliku


14.TYPY PLIKÓW
----------
d -katalog , l -link symboliczny , p -potok , b -block dev ,c -character dev (dev/console) , s -socet gniazdo

15.SKRÓTY
-------

	Podstawy:
	---------

TAB – automatyczne dokończenie nazwy zaczętego polecenia ,( /etc/bash_completion - tu jest auto autocompletion , a w bashrc jest uruchamiane przy każdej sesji)
TAB – wciśnięte dwa razy – w przypadku gdy powłoka nie jest w stanie dokończyć zaczętego polecenia powtórne wciśnięcie klawisza TAB spowoduje wyświetlenie podpowiedzi z listą dostępnych komend zaczynających się od wpisanej wartości.
(↑ | ↓) – strzałki góra / dół – Poruszanie się po historii poleceń, które wcześniej były już wpisywane w konsole,
CTRL+P / CTRL+N – tak samo jak w przypadku strzałek – poruszanie się po historii poleceń, które wcześniej były już wpisywane w konsole,
CTRL+R – wyszukuje w historii poleceń wcześniej już wykonanych, po wciśnięciu skrótu wpisujemy początkowy jakiejś komendy – i otrzymujemy podpowiedź
Ctrl+G – wychodzi z wyszukiwania historii poleceń
ALT+. – wkleja ostatnie słowo z poprzedniego polecenia
^słowo^zamiennik – zastępuje słowo zamiennikiem w poprzednim poleceniu
CTRL+C – przerwanie/zabicie działania programu
CTRL+Z – zatrzymanie działania programu
CTRL+S – zatrzymanie transferu do terminala
CTRL+Q – kontynuowanie transferu do terminala – (jeśli wcześniej użyto ctrl+s)
CTRL+L – wyczyszczenie ekranu (działa jak polecenie clear)
!! – wykonaj ostatnie polecenie
!wpis – wykonaj najczęściej wykonywane polecenie zaczynające się od wpis
!wpis:p – to samo co wyżej, tylko bez wykonywania (wyświetlenie pełnej nazwy komendy)
CTRL+x+e  - uruchamia domyślny edytor tekstu , wpisujemy nasze polecenie ,zapisujemy i wychodzimy ,polecenie się wykonuje
CTRL+j - enter , powrót karetki
CTRL+d - exit

	Skróty przeznaczone do edycji polecenia:
	---------------------------------------

Ctrl+A – przesuwa kursor na początek linii
Ctrl+E – przesuwa kursor na koniec linii
Ctrl+K – usuwa wszystko od kursora do końca linii
Ctrl+U – usuwa wszystko od kursora do początku linii
Ctrl+W – usuwa słowo przed kursorem
Ctrl+Y – wkleja poprzednio wymazany fragment poprzez Ctl-U oraz Ctl-K,W
Ctrl+D – usuwa literę przed kursorem (lub słowo – również ALT+BackSpace)
Alt+B – cofa kursor o słowo do tyłu
Alt+F – przenosi kursor o słowo do przodu
Alt+T – zmienia kolejność wpisywanych słów
Alt+C – Zamienia pierwszą literę w wyrazie na Wielką, a kolejne na małe.
Alt+L – Zamienia wszystkie znaki w wyrazie na prawo od kursora na małe litery
Alt+U – Zamienia wszystkie znaki w wyrazie na prawo od kursora na Wielkie litery

	Skróty okien:
	-------------
CTRL+ALT+F1 – Przełącza na pierwszy terminal.
CTRL+ALT+FN (N=1..6) – Przełącza na następne terminale.
tty – wyświetla nazwę bieżącego terminalu.
CTRL+ALT+F7 – Przełącza na pierwszy terminal graficzny (jest na tym terminalu uruchomiony jest X-window).
CTRL+ALT+FN (n=7..12) – Przełącza na następny terminal graficzny (jeśli terminal GUI jest uruchomiony na ekranie n-1).
SHIFT+PgUp – przewija dane wyjściowe z terminala w górę.
SHIFT+PgDown – przewija dane wyjściowe z terminala w dół.
CTRL+ALT+ESC – zabija okno w które klikniesz myszką
CTRL+ALT+BACKSPACE – zabija środowisko graficzne lub je restartuje. Warto skorzystać z tej kombinacji, kiedy wszystko inne przestało działać.

	Inne:
	-----

Alt-Ctrl-L Blokada komputera
Alt-F1 Otwiera menu Aplikacje (dalej można się po nim poruszać strzałkami)
Alt-F2 Otwiera menu ‘Uruchom’
Alt-F3 Otwiera menu wyszukiwania (Deskbar)
Alt-F4 Zamyka aktywne okno
Alt-F5 Pomniejsza okno (jeśli jest na pełnym ekranie)
Alt-F7 Pozwala na przesuwanie okna za pomocą strzałek
Alt-F8 Pozwala na zmianę rozmiaru okna za pomocą strzałek
Alt-F9 Minimalizuje aktywne okno
Alt-F10 Maksymalizuje aktywne okno

SZTUCZKI
--------
^tak^nie - w poprzedniej komendzie gdzie było słow "tak" zostanie zastąpione przez "nie" i ponownie wywołane

16.SYSTEMD
-------
 
who -r -sprwadza run level
systemctl list-units - lista aktywnych jednostek systemd
	--full -pełne nazwy
	--all -wszystkie jednostki ,nie tylko te uruchomione (-a)
systemctl show -p typ_jednostki --podgląd zależności jednostki systemd
systemctl status nazwa_jednostki --info ostatusie jednostki
systemctl disable nazwa jednostki --jednosta nadal będzie działć ale nie zostanie
	ponownie uruchomina przy ponownym włączeniu systemu
systemd-cgls --info o grupie kontrolnej w oderwaniu od tanu samej jednostki
pkg-config systemd --variable=systemdunitdir -katalogi jednostek systemowych
pkg-config systemd --variable=systemdconfdir -katalogi jednostek konfiguracyjnych 
systemd start -aktywacja jednostki
	stop , restart - deaktywuje , restartuje
systemctl reload jednostka - ponownie ładuje conf. jednostki
systemctl daemon-reload - ponownie ładuje conf. wszystkich jednostek
systemctl list-jobs - lista prac (żądań aktywacji i deaktywacji jednostek)
systemctl poweroff - wyłącza maszyne
systemctl reboot - rebootuje maszune 
	start unit -aktywacja jednostki
	stop , restart - deaktywuje , restartuje
	disable unit - jeśli ma sekcje [install] trzeba ją wyłączyć aby
	usunąć ewentualne dowiązania symboliczne
systemctl reload jednostka - ponownie ładuje conf. jednostki
systemctl daemon-reload - ponownie ładuje conf. wszystkich jednostek
systemctl list-jobs - lista prac (żądań aktywacji i deaktywacji jednostek)
	???--- trudno podejżeć prace bo systemd raczej szybciej je zakończy ,
	ale można szybko się zalogować i spróbować ---???
	???--- praca zakończona ni oznacza wyłączenia jednostki , może ona być 
	nadal aktywna ,np; usługa ---???
systemd --failed -pokaże usługi które nie uruchomiły się przy starcie maszyny
	można potem zrobić status i zobaczyć szczeguły
	systemctl status unit_co_faild
systemctl is-enabled jakiś_unit -wyświetli czy jest enabled czy disabled
systemctl journal -logi
	-b -od ostatnigo boota
	-u unit -logi tego unita

17.CRONTAB
----------

???--- polecenie dla crona można zapisać w pliku a następnie podać ścieżkę przy wywołaniu crontab--???
crontab -l -listuje zadania
	-r -usówa wcześniej zainstalowany plik crontab
	-e -jednoczesna edycja i instalaca pliku crontab
	EDYCJA CRONTAB
	-------------
	minuta godz dzien dzień_miesiąca miesiąc dzień_tyg nasze_polecenie
	W tabelach oprócz zadań możemy definiować zmienne środowiskowe np.:
	SHELL=/bin/bash
	PATH=/sbin:/bin:/usr/sbin:/usr/bin
	MAILTO=jakis_user
	NICE=15
	
	SHELL=/bin/bash
	PATH=/sbin:/bin:/usr/sbin:/usr/bin
	MAILTO=jakis_user
	NICE=15

18.USŁUGI.SEVICES
-----------------

 ???--- Na Debiani ,ubuntu .mint uruchamiane usługi automatycznie startują , w innym przypadku tzrba je statować ---???
service --status-all  -status usług
acct - włączenie/wyłączenie ewidencjonowania procesów . Dmoyślnie może jej nie być i trzeba ją zainstalować
	systemctl enable acct - uruchamiamt usługe , startujemy jak sama nie wystowała.
